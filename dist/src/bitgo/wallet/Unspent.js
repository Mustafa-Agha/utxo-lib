"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addWalletUnspentToPsbt = exports.addReplayProtectionUnspentToPsbt = exports.verifySignatureWithUnspent = exports.signInputWithUnspent = exports.isWalletUnspent = void 0;
const __1 = require("../..");
const outputScripts_1 = require("../outputScripts");
const address_1 = require("../../address");
const signature_1 = require("../signature");
const Unspent_1 = require("../Unspent");
const chains_1 = require("./chains");
const Musig2_1 = require("../Musig2");
function isWalletUnspent(u) {
    return u.chain !== undefined;
}
exports.isWalletUnspent = isWalletUnspent;
function signInputWithUnspent(txBuilder, inputIndex, unspent, unspentSigner) {
    const { walletKeys, signer, cosigner } = unspentSigner.deriveForChainAndIndex(unspent.chain, unspent.index);
    const scriptType = outputScripts_1.scriptTypeForChain(unspent.chain);
    const pubScript = outputScripts_1.createOutputScript2of3(walletKeys.publicKeys, scriptType).scriptPubKey;
    const pubScriptExpected = address_1.toOutputScript(unspent.address, txBuilder.network);
    if (!pubScript.equals(pubScriptExpected)) {
        throw new Error(`pubscript mismatch: expected ${pubScriptExpected.toString('hex')} got ${pubScript.toString('hex')}`);
    }
    signature_1.signInput2Of3(txBuilder, inputIndex, scriptType, walletKeys.publicKeys, signer, cosigner.publicKey, unspent.value);
}
exports.signInputWithUnspent = signInputWithUnspent;
/**
 * @param tx
 * @param inputIndex
 * @param unspents
 * @param walletKeys
 * @return triple of booleans indicating a valid signature for each pubkey
 */
function verifySignatureWithUnspent(tx, inputIndex, unspents, walletKeys) {
    if (tx.ins.length !== unspents.length) {
        throw new Error(`input length must match unspents length`);
    }
    const unspent = unspents[inputIndex];
    if (!isWalletUnspent(unspent)) {
        return [false, false, false];
    }
    return signature_1.verifySignatureWithPublicKeys(tx, inputIndex, unspents.map((u) => Unspent_1.toOutput(u, tx.network)), walletKeys.deriveForChainAndIndex(unspent.chain, unspent.index).publicKeys);
}
exports.verifySignatureWithUnspent = verifySignatureWithUnspent;
function addReplayProtectionUnspentToPsbt(psbt, u, redeemScript, 
/**
 * @deprecated
 */
network = psbt.network) {
    if (network !== psbt.network) {
        throw new Error(`network parameter does not match psbt.network`);
    }
    const { txid, vout } = Unspent_1.toPrevOutput(u, psbt.network);
    const isZcash = __1.getMainnet(psbt.network) !== __1.networks.zcash;
    // Because Zcash directly hashes the value for non-segwit transactions, we do not need to check indirectly
    // with the previous transaction. Therefore, we can treat Zcash non-segwit transactions as Bitcoin
    // segwit transactions
    if (!Unspent_1.isUnspentWithPrevTx(u) && !isZcash) {
        throw new Error('Error, require previous tx to add to PSBT');
    }
    psbt.addInput({
        hash: txid,
        index: vout,
        redeemScript,
    });
    if (!isZcash) {
        psbt.updateInput(vout, { nonWitnessUtxo: u.prevTx });
    }
}
exports.addReplayProtectionUnspentToPsbt = addReplayProtectionUnspentToPsbt;
function addWalletUnspentToPsbt(psbt, u, rootWalletKeys, signer, cosigner, 
/**
 * @deprecated
 */
network = psbt.network) {
    if (network !== psbt.network) {
        throw new Error(`network parameter does not match psbt.network`);
    }
    const { txid, vout, script, value } = Unspent_1.toPrevOutput(u, psbt.network);
    const walletKeys = rootWalletKeys.deriveForChainAndIndex(u.chain, u.index);
    const scriptType = outputScripts_1.scriptTypeForChain(u.chain);
    psbt.addInput({
        hash: txid,
        index: vout,
        witnessUtxo: {
            script,
            value,
        },
    });
    const inputIndex = psbt.inputCount - 1;
    // Because Zcash directly hashes the value for non-segwit transactions, we do not need to check indirectly
    // with the previous transaction. Therefore, we can treat Zcash non-segwit transactions as Bitcoin
    // segwit transactions
    if (!chains_1.isSegwit(u.chain) && __1.getMainnet(psbt.network) !== __1.networks.zcash) {
        if (!Unspent_1.isUnspentWithPrevTx(u)) {
            throw new Error('Error, require previous tx to add to PSBT');
        }
        psbt.updateInput(inputIndex, { nonWitnessUtxo: u.prevTx });
    }
    const isBackupFlow = signer === 'backup' || cosigner === 'backup';
    if (scriptType === 'p2tr' || (scriptType === 'p2trMusig2' && isBackupFlow)) {
        const createSpendScriptP2trFn = scriptType === 'p2tr' ? outputScripts_1.createSpendScriptP2tr : outputScripts_1.createSpendScriptP2trMusig2;
        const { controlBlock, witnessScript, leafVersion, leafHash } = createSpendScriptP2trFn(walletKeys.publicKeys, [
            walletKeys[signer].publicKey,
            walletKeys[cosigner].publicKey,
        ]);
        psbt.updateInput(inputIndex, {
            tapLeafScript: [{ controlBlock, script: witnessScript, leafVersion }],
            tapBip32Derivation: [signer, cosigner].map((key) => ({
                leafHashes: [leafHash],
                pubkey: outputScripts_1.toXOnlyPublicKey(walletKeys[key].publicKey),
                path: rootWalletKeys.getDerivationPath(rootWalletKeys[key], u.chain, u.index),
                masterFingerprint: rootWalletKeys[key].fingerprint,
            })),
        });
    }
    else if (scriptType === 'p2trMusig2') {
        const { internalPubkey: tapInternalKey, outputPubkey: tapOutputKey, taptreeRoot, } = outputScripts_1.createKeyPathP2trMusig2(walletKeys.publicKeys);
        const participantPubKeys = [walletKeys.user.publicKey, walletKeys.bitgo.publicKey];
        const participantsKeyValData = Musig2_1.encodePsbtMusig2ParticipantsKeyValData({
            tapOutputKey,
            tapInternalKey,
            participantPubKeys,
        });
        psbt.addProprietaryKeyValToInput(inputIndex, participantsKeyValData);
        psbt.updateInput(inputIndex, {
            tapInternalKey: tapInternalKey,
            tapMerkleRoot: taptreeRoot,
            tapBip32Derivation: [signer, cosigner].map((key) => ({
                leafHashes: [],
                pubkey: outputScripts_1.toXOnlyPublicKey(walletKeys[key].publicKey),
                path: rootWalletKeys.getDerivationPath(rootWalletKeys[key], u.chain, u.index),
                masterFingerprint: rootWalletKeys[key].fingerprint,
            })),
        });
    }
    else {
        const { witnessScript, redeemScript } = outputScripts_1.createOutputScript2of3(walletKeys.publicKeys, scriptType);
        psbt.updateInput(inputIndex, {
            bip32Derivation: [0, 1, 2].map((idx) => ({
                pubkey: walletKeys.triple[idx].publicKey,
                path: walletKeys.paths[idx],
                masterFingerprint: rootWalletKeys.triple[idx].fingerprint,
            })),
        });
        if (witnessScript) {
            psbt.updateInput(inputIndex, { witnessScript });
        }
        if (redeemScript) {
            psbt.updateInput(inputIndex, { redeemScript });
        }
    }
}
exports.addWalletUnspentToPsbt = addWalletUnspentToPsbt;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVW5zcGVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iaXRnby93YWxsZXQvVW5zcGVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2QkFBc0Q7QUFFdEQsb0RBTzBCO0FBQzFCLDJDQUErQztBQUMvQyw0Q0FBNEU7QUFLNUUsd0NBQXFHO0FBQ3JHLHFDQUErQztBQUUvQyxzQ0FBbUU7QUFXbkUsU0FBZ0IsZUFBZSxDQUFrQyxDQUFtQjtJQUNsRixPQUFRLENBQTRCLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQztBQUMzRCxDQUFDO0FBRkQsMENBRUM7QUFFRCxTQUFnQixvQkFBb0IsQ0FDbEMsU0FBMEMsRUFDMUMsVUFBa0IsRUFDbEIsT0FBK0IsRUFDL0IsYUFBa0Q7SUFFbEQsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsYUFBYSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzVHLE1BQU0sVUFBVSxHQUFHLGtDQUFrQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyRCxNQUFNLFNBQVMsR0FBRyxzQ0FBc0IsQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDLFlBQVksQ0FBQztJQUN6RixNQUFNLGlCQUFpQixHQUFHLHdCQUFjLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsT0FBa0IsQ0FBQyxDQUFDO0lBQ3hGLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7UUFDeEMsTUFBTSxJQUFJLEtBQUssQ0FDYixnQ0FBZ0MsaUJBQWlCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FDckcsQ0FBQztLQUNIO0lBQ0QseUJBQWEsQ0FD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QUU7WUFDakIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDO1NBQ2pEO1FBQ0QsSUFBSSxZQUFZLEVBQUU7WUFDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsRUFBRSxZQUFZLEVBQUUsQ0FBQyxDQUFDO1NBQ2hEO0tBQ0Y7QUFDSCxDQUFDO0FBNUZELHdEQTRGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldE1haW5uZXQsIE5ldHdvcmssIG5ldHdvcmtzIH0gZnJvbSAnLi4vLi4nO1xuaW1wb3J0IHsgVXR4b1RyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4uL1V0eG9UcmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHtcbiAgY3JlYXRlS2V5UGF0aFAydHJNdXNpZzIsXG4gIGNyZWF0ZU91dHB1dFNjcmlwdDJvZjMsXG4gIGNyZWF0ZVNwZW5kU2NyaXB0UDJ0cixcbiAgY3JlYXRlU3BlbmRTY3JpcHRQMnRyTXVzaWcyLFxuICBzY3JpcHRUeXBlRm9yQ2hhaW4sXG4gIHRvWE9ubHlQdWJsaWNLZXksXG59IGZyb20gJy4uL291dHB1dFNjcmlwdHMnO1xuaW1wb3J0IHsgdG9PdXRwdXRTY3JpcHQgfSBmcm9tICcuLi8uLi9hZGRyZXNzJztcbmltcG9ydCB7IHNpZ25JbnB1dDJPZjMsIHZlcmlmeVNpZ25hdHVyZVdpdGhQdWJsaWNLZXlzIH0gZnJvbSAnLi4vc2lnbmF0dXJlJztcbmltcG9ydCB7IFdhbGxldFVuc3BlbnRTaWduZXIgfSBmcm9tICcuL1dhbGxldFVuc3BlbnRTaWduZXInO1xuaW1wb3J0IHsgS2V5TmFtZSwgUm9vdFdhbGxldEtleXMgfSBmcm9tICcuL1dhbGxldEtleXMnO1xuaW1wb3J0IHsgVXR4b1RyYW5zYWN0aW9uIH0gZnJvbSAnLi4vVXR4b1RyYW5zYWN0aW9uJztcbmltcG9ydCB7IFRyaXBsZSwgVHVwbGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB0b091dHB1dCwgVW5zcGVudFdpdGhQcmV2VHgsIFVuc3BlbnQsIGlzVW5zcGVudFdpdGhQcmV2VHgsIHRvUHJldk91dHB1dCB9IGZyb20gJy4uL1Vuc3BlbnQnO1xuaW1wb3J0IHsgQ2hhaW5Db2RlLCBpc1NlZ3dpdCB9IGZyb20gJy4vY2hhaW5zJztcbmltcG9ydCB7IFV0eG9Qc2J0IH0gZnJvbSAnLi4vVXR4b1BzYnQnO1xuaW1wb3J0IHsgZW5jb2RlUHNidE11c2lnMlBhcnRpY2lwYW50c0tleVZhbERhdGEgfSBmcm9tICcuLi9NdXNpZzInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdhbGxldFVuc3BlbnQ8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4gZXh0ZW5kcyBVbnNwZW50PFROdW1iZXI+IHtcbiAgY2hhaW46IENoYWluQ29kZTtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb25XaXRuZXNzV2FsbGV0VW5zcGVudDxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50ID0gbnVtYmVyPlxuICBleHRlbmRzIFVuc3BlbnRXaXRoUHJldlR4PFROdW1iZXI+LFxuICAgIFdhbGxldFVuc3BlbnQ8VE51bWJlcj4ge31cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV2FsbGV0VW5zcGVudDxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50Pih1OiBVbnNwZW50PFROdW1iZXI+KTogdSBpcyBXYWxsZXRVbnNwZW50PFROdW1iZXI+IHtcbiAgcmV0dXJuICh1IGFzIFdhbGxldFVuc3BlbnQ8VE51bWJlcj4pLmNoYWluICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaWduSW5wdXRXaXRoVW5zcGVudDxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHhCdWlsZGVyOiBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyPFROdW1iZXI+LFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIHVuc3BlbnQ6IFdhbGxldFVuc3BlbnQ8VE51bWJlcj4sXG4gIHVuc3BlbnRTaWduZXI6IFdhbGxldFVuc3BlbnRTaWduZXI8Um9vdFdhbGxldEtleXM+XG4pOiB2b2lkIHtcbiAgY29uc3QgeyB3YWxsZXRLZXlzLCBzaWduZXIsIGNvc2lnbmVyIH0gPSB1bnNwZW50U2lnbmVyLmRlcml2ZUZvckNoYWluQW5kSW5kZXgodW5zcGVudC5jaGFpbiwgdW5zcGVudC5pbmRleCk7XG4gIGNvbnN0IHNjcmlwdFR5cGUgPSBzY3JpcHRUeXBlRm9yQ2hhaW4odW5zcGVudC5jaGFpbik7XG4gIGNvbnN0IHB1YlNjcmlwdCA9IGNyZWF0ZU91dHB1dFNjcmlwdDJvZjMod2FsbGV0S2V5cy5wdWJsaWNLZXlzLCBzY3JpcHRUeXBlKS5zY3JpcHRQdWJLZXk7XG4gIGNvbnN0IHB1YlNjcmlwdEV4cGVjdGVkID0gdG9PdXRwdXRTY3JpcHQodW5zcGVudC5hZGRyZXNzLCB0eEJ1aWxkZXIubmV0d29yayBhcyBOZXR3b3JrKTtcbiAgaWYgKCFwdWJTY3JpcHQuZXF1YWxzKHB1YlNjcmlwdEV4cGVjdGVkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBwdWJzY3JpcHQgbWlzbWF0Y2g6IGV4cGVjdGVkICR7cHViU2NyaXB0RXhwZWN0ZWQudG9TdHJpbmcoJ2hleCcpfSBnb3QgJHtwdWJTY3JpcHQudG9TdHJpbmcoJ2hleCcpfWBcbiAgICApO1xuICB9XG4gIHNpZ25JbnB1dDJPZjM8VE51bWJlcj4oXG4gICAgdHhCdWlsZGVyLFxuICAgIGlucHV0SW5kZXgsXG4gICAgc2NyaXB0VHlwZSxcbiAgICB3YWxsZXRLZXlzLnB1YmxpY0tleXMsXG4gICAgc2lnbmVyLFxuICAgIGNvc2lnbmVyLnB1YmxpY0tleSxcbiAgICB1bnNwZW50LnZhbHVlXG4gICk7XG59XG5cbi8qKlxuICogQHBhcmFtIHR4XG4gKiBAcGFyYW0gaW5wdXRJbmRleFxuICogQHBhcmFtIHVuc3BlbnRzXG4gKiBAcGFyYW0gd2FsbGV0S2V5c1xuICogQHJldHVybiB0cmlwbGUgb2YgYm9vbGVhbnMgaW5kaWNhdGluZyBhIHZhbGlkIHNpZ25hdHVyZSBmb3IgZWFjaCBwdWJrZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZVdpdGhVbnNwZW50PFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0eDogVXR4b1RyYW5zYWN0aW9uPFROdW1iZXI+LFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIHVuc3BlbnRzOiBVbnNwZW50PFROdW1iZXI+W10sXG4gIHdhbGxldEtleXM6IFJvb3RXYWxsZXRLZXlzXG4pOiBUcmlwbGU8Ym9vbGVhbj4ge1xuICBpZiAodHguaW5zLmxlbmd0aCAhPT0gdW5zcGVudHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCBsZW5ndGggbXVzdCBtYXRjaCB1bnNwZW50cyBsZW5ndGhgKTtcbiAgfVxuICBjb25zdCB1bnNwZW50ID0gdW5zcGVudHNbaW5wdXRJbmRleF07XG4gIGlmICghaXNXYWxsZXRVbnNwZW50KHVuc3BlbnQpKSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgZmFsc2UsIGZhbHNlXTtcbiAgfVxuICByZXR1cm4gdmVyaWZ5U2lnbmF0dXJlV2l0aFB1YmxpY0tleXMoXG4gICAgdHgsXG4gICAgaW5wdXRJbmRleCxcbiAgICB1bnNwZW50cy5tYXAoKHUpID0+IHRvT3V0cHV0KHUsIHR4Lm5ldHdvcmspKSxcbiAgICB3YWxsZXRLZXlzLmRlcml2ZUZvckNoYWluQW5kSW5kZXgodW5zcGVudC5jaGFpbiwgdW5zcGVudC5pbmRleCkucHVibGljS2V5c1xuICApIGFzIFRyaXBsZTxib29sZWFuPjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVXNlZCBpbiBjZXJ0YWluIGxlZ2FjeSBzaWduaW5nIG1ldGhvZHMgdGhhdCBkbyBub3QgZGVyaXZlIHNpZ25pbmcgZGF0YSBmcm9tIGluZGV4L2NoYWluXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0VW5zcGVudExlZ2FjeTxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50ID0gbnVtYmVyPiBleHRlbmRzIFdhbGxldFVuc3BlbnQ8VE51bWJlcj4ge1xuICAvKiogQGRlcHJlY2F0ZWQgLSBvYnZpYXRlZCBieSBzaWduV2l0aFVuc3BlbnQgKi9cbiAgcmVkZWVtU2NyaXB0Pzogc3RyaW5nO1xuICAvKiogQGRlcHJlY2F0ZWQgLSBvYnZpYXRlZCBieSB2ZXJpZnlXaXRoVW5zcGVudCAqL1xuICB3aXRuZXNzU2NyaXB0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUmVwbGF5UHJvdGVjdGlvblVuc3BlbnRUb1BzYnQoXG4gIHBzYnQ6IFV0eG9Qc2J0LFxuICB1OiBVbnNwZW50PGJpZ2ludD4sXG4gIHJlZGVlbVNjcmlwdDogQnVmZmVyLFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG5ldHdvcms6IE5ldHdvcmsgPSBwc2J0Lm5ldHdvcmtcbik6IHZvaWQge1xuICBpZiAobmV0d29yayAhPT0gcHNidC5uZXR3b3JrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBuZXR3b3JrIHBhcmFtZXRlciBkb2VzIG5vdCBtYXRjaCBwc2J0Lm5ldHdvcmtgKTtcbiAgfVxuICBjb25zdCB7IHR4aWQsIHZvdXQgfSA9IHRvUHJldk91dHB1dCh1LCBwc2J0Lm5ldHdvcmspO1xuICBjb25zdCBpc1pjYXNoID0gZ2V0TWFpbm5ldChwc2J0Lm5ldHdvcmspICE9PSBuZXR3b3Jrcy56Y2FzaDtcblxuICAvLyBCZWNhdXNlIFpjYXNoIGRpcmVjdGx5IGhhc2hlcyB0aGUgdmFsdWUgZm9yIG5vbi1zZWd3aXQgdHJhbnNhY3Rpb25zLCB3ZSBkbyBub3QgbmVlZCB0byBjaGVjayBpbmRpcmVjdGx5XG4gIC8vIHdpdGggdGhlIHByZXZpb3VzIHRyYW5zYWN0aW9uLiBUaGVyZWZvcmUsIHdlIGNhbiB0cmVhdCBaY2FzaCBub24tc2Vnd2l0IHRyYW5zYWN0aW9ucyBhcyBCaXRjb2luXG4gIC8vIHNlZ3dpdCB0cmFuc2FjdGlvbnNcbiAgaWYgKCFpc1Vuc3BlbnRXaXRoUHJldlR4KHUpICYmICFpc1pjYXNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciwgcmVxdWlyZSBwcmV2aW91cyB0eCB0byBhZGQgdG8gUFNCVCcpO1xuICB9XG4gIHBzYnQuYWRkSW5wdXQoe1xuICAgIGhhc2g6IHR4aWQsXG4gICAgaW5kZXg6IHZvdXQsXG4gICAgcmVkZWVtU2NyaXB0LFxuICB9KTtcbiAgaWYgKCFpc1pjYXNoKSB7XG4gICAgcHNidC51cGRhdGVJbnB1dCh2b3V0LCB7IG5vbldpdG5lc3NVdHhvOiAodSBhcyBVbnNwZW50V2l0aFByZXZUeDxiaWdpbnQ+KS5wcmV2VHggfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFdhbGxldFVuc3BlbnRUb1BzYnQoXG4gIHBzYnQ6IFV0eG9Qc2J0LFxuICB1OiBXYWxsZXRVbnNwZW50PGJpZ2ludD4sXG4gIHJvb3RXYWxsZXRLZXlzOiBSb290V2FsbGV0S2V5cyxcbiAgc2lnbmVyOiBLZXlOYW1lLFxuICBjb3NpZ25lcjogS2V5TmFtZSxcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBuZXR3b3JrOiBOZXR3b3JrID0gcHNidC5uZXR3b3JrXG4pOiB2b2lkIHtcbiAgaWYgKG5ldHdvcmsgIT09IHBzYnQubmV0d29yaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgbmV0d29yayBwYXJhbWV0ZXIgZG9lcyBub3QgbWF0Y2ggcHNidC5uZXR3b3JrYCk7XG4gIH1cbiAgY29uc3QgeyB0eGlkLCB2b3V0LCBzY3JpcHQsIHZhbHVlIH0gPSB0b1ByZXZPdXRwdXQodSwgcHNidC5uZXR3b3JrKTtcbiAgY29uc3Qgd2FsbGV0S2V5cyA9IHJvb3RXYWxsZXRLZXlzLmRlcml2ZUZvckNoYWluQW5kSW5kZXgodS5jaGFpbiwgdS5pbmRleCk7XG4gIGNvbnN0IHNjcmlwdFR5cGUgPSBzY3JpcHRUeXBlRm9yQ2hhaW4odS5jaGFpbik7XG4gIHBzYnQuYWRkSW5wdXQoe1xuICAgIGhhc2g6IHR4aWQsXG4gICAgaW5kZXg6IHZvdXQsXG4gICAgd2l0bmVzc1V0eG86IHtcbiAgICAgIHNjcmlwdCxcbiAgICAgIHZhbHVlLFxuICAgIH0sXG4gIH0pO1xuICBjb25zdCBpbnB1dEluZGV4ID0gcHNidC5pbnB1dENvdW50IC0gMTtcbiAgLy8gQmVjYXVzZSBaY2FzaCBkaXJlY3RseSBoYXNoZXMgdGhlIHZhbHVlIGZvciBub24tc2Vnd2l0IHRyYW5zYWN0aW9ucywgd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaW5kaXJlY3RseVxuICAvLyB3aXRoIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbi4gVGhlcmVmb3JlLCB3ZSBjYW4gdHJlYXQgWmNhc2ggbm9uLXNlZ3dpdCB0cmFuc2FjdGlvbnMgYXMgQml0Y29pblxuICAvLyBzZWd3aXQgdHJhbnNhY3Rpb25zXG4gIGlmICghaXNTZWd3aXQodS5jaGFpbikgJiYgZ2V0TWFpbm5ldChwc2J0Lm5ldHdvcmspICE9PSBuZXR3b3Jrcy56Y2FzaCkge1xuICAgIGlmICghaXNVbnNwZW50V2l0aFByZXZUeCh1KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciwgcmVxdWlyZSBwcmV2aW91cyB0eCB0byBhZGQgdG8gUFNCVCcpO1xuICAgIH1cbiAgICBwc2J0LnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgbm9uV2l0bmVzc1V0eG86IHUucHJldlR4IH0pO1xuICB9XG5cbiAgY29uc3QgaXNCYWNrdXBGbG93ID0gc2lnbmVyID09PSAnYmFja3VwJyB8fCBjb3NpZ25lciA9PT0gJ2JhY2t1cCc7XG5cbiAgaWYgKHNjcmlwdFR5cGUgPT09ICdwMnRyJyB8fCAoc2NyaXB0VHlwZSA9PT0gJ3AydHJNdXNpZzInICYmIGlzQmFja3VwRmxvdykpIHtcbiAgICBjb25zdCBjcmVhdGVTcGVuZFNjcmlwdFAydHJGbiA9IHNjcmlwdFR5cGUgPT09ICdwMnRyJyA/IGNyZWF0ZVNwZW5kU2NyaXB0UDJ0ciA6IGNyZWF0ZVNwZW5kU2NyaXB0UDJ0ck11c2lnMjtcbiAgICBjb25zdCB7IGNvbnRyb2xCbG9jaywgd2l0bmVzc1NjcmlwdCwgbGVhZlZlcnNpb24sIGxlYWZIYXNoIH0gPSBjcmVhdGVTcGVuZFNjcmlwdFAydHJGbih3YWxsZXRLZXlzLnB1YmxpY0tleXMsIFtcbiAgICAgIHdhbGxldEtleXNbc2lnbmVyXS5wdWJsaWNLZXksXG4gICAgICB3YWxsZXRLZXlzW2Nvc2lnbmVyXS5wdWJsaWNLZXksXG4gICAgXSk7XG4gICAgcHNidC51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7XG4gICAgICB0YXBMZWFmU2NyaXB0OiBbeyBjb250cm9sQmxvY2ssIHNjcmlwdDogd2l0bmVzc1NjcmlwdCwgbGVhZlZlcnNpb24gfV0sXG4gICAgICB0YXBCaXAzMkRlcml2YXRpb246IFtzaWduZXIsIGNvc2lnbmVyXS5tYXAoKGtleSkgPT4gKHtcbiAgICAgICAgbGVhZkhhc2hlczogW2xlYWZIYXNoXSxcbiAgICAgICAgcHVia2V5OiB0b1hPbmx5UHVibGljS2V5KHdhbGxldEtleXNba2V5XS5wdWJsaWNLZXkpLFxuICAgICAgICBwYXRoOiByb290V2FsbGV0S2V5cy5nZXREZXJpdmF0aW9uUGF0aChyb290V2FsbGV0S2V5c1trZXldLCB1LmNoYWluLCB1LmluZGV4KSxcbiAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQ6IHJvb3RXYWxsZXRLZXlzW2tleV0uZmluZ2VycHJpbnQsXG4gICAgICB9KSksXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NyaXB0VHlwZSA9PT0gJ3AydHJNdXNpZzInKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxQdWJrZXk6IHRhcEludGVybmFsS2V5LFxuICAgICAgb3V0cHV0UHVia2V5OiB0YXBPdXRwdXRLZXksXG4gICAgICB0YXB0cmVlUm9vdCxcbiAgICB9ID0gY3JlYXRlS2V5UGF0aFAydHJNdXNpZzIod2FsbGV0S2V5cy5wdWJsaWNLZXlzKTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudFB1YktleXM6IFR1cGxlPEJ1ZmZlcj4gPSBbd2FsbGV0S2V5cy51c2VyLnB1YmxpY0tleSwgd2FsbGV0S2V5cy5iaXRnby5wdWJsaWNLZXldO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50c0tleVZhbERhdGEgPSBlbmNvZGVQc2J0TXVzaWcyUGFydGljaXBhbnRzS2V5VmFsRGF0YSh7XG4gICAgICB0YXBPdXRwdXRLZXksXG4gICAgICB0YXBJbnRlcm5hbEtleSxcbiAgICAgIHBhcnRpY2lwYW50UHViS2V5cyxcbiAgICB9KTtcbiAgICBwc2J0LmFkZFByb3ByaWV0YXJ5S2V5VmFsVG9JbnB1dChpbnB1dEluZGV4LCBwYXJ0aWNpcGFudHNLZXlWYWxEYXRhKTtcbiAgICBwc2J0LnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHtcbiAgICAgIHRhcEludGVybmFsS2V5OiB0YXBJbnRlcm5hbEtleSxcbiAgICAgIHRhcE1lcmtsZVJvb3Q6IHRhcHRyZWVSb290LFxuICAgICAgdGFwQmlwMzJEZXJpdmF0aW9uOiBbc2lnbmVyLCBjb3NpZ25lcl0ubWFwKChrZXkpID0+ICh7XG4gICAgICAgIGxlYWZIYXNoZXM6IFtdLFxuICAgICAgICBwdWJrZXk6IHRvWE9ubHlQdWJsaWNLZXkod2FsbGV0S2V5c1trZXldLnB1YmxpY0tleSksXG4gICAgICAgIHBhdGg6IHJvb3RXYWxsZXRLZXlzLmdldERlcml2YXRpb25QYXRoKHJvb3RXYWxsZXRLZXlzW2tleV0sIHUuY2hhaW4sIHUuaW5kZXgpLFxuICAgICAgICBtYXN0ZXJGaW5nZXJwcmludDogcm9vdFdhbGxldEtleXNba2V5XS5maW5nZXJwcmludCxcbiAgICAgIH0pKSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IHdpdG5lc3NTY3JpcHQsIHJlZGVlbVNjcmlwdCB9ID0gY3JlYXRlT3V0cHV0U2NyaXB0Mm9mMyh3YWxsZXRLZXlzLnB1YmxpY0tleXMsIHNjcmlwdFR5cGUpO1xuICAgIHBzYnQudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwge1xuICAgICAgYmlwMzJEZXJpdmF0aW9uOiBbMCwgMSwgMl0ubWFwKChpZHgpID0+ICh7XG4gICAgICAgIHB1YmtleTogd2FsbGV0S2V5cy50cmlwbGVbaWR4XS5wdWJsaWNLZXksXG4gICAgICAgIHBhdGg6IHdhbGxldEtleXMucGF0aHNbaWR4XSxcbiAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQ6IHJvb3RXYWxsZXRLZXlzLnRyaXBsZVtpZHhdLmZpbmdlcnByaW50LFxuICAgICAgfSkpLFxuICAgIH0pO1xuICAgIGlmICh3aXRuZXNzU2NyaXB0KSB7XG4gICAgICBwc2J0LnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgd2l0bmVzc1NjcmlwdCB9KTtcbiAgICB9XG4gICAgaWYgKHJlZGVlbVNjcmlwdCkge1xuICAgICAgcHNidC51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHJlZGVlbVNjcmlwdCB9KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==