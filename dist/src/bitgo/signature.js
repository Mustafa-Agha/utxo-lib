"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signInput2Of3 = exports.signInputP2shP2pk = exports.getDefaultSigHash = exports.verifySignatureWithPublicKey = exports.verifySignatureWithPublicKeys = exports.getSignaturesWithPublicKeys = exports.verifySignature = exports.getSignatureVerifications = void 0;
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const UtxoTransaction_1 = require("./UtxoTransaction");
const outputScripts_1 = require("./outputScripts");
const networks_1 = require("../networks");
const noble_ecc_1 = require("../noble_ecc");
const parseInput_1 = require("./parseInput");
/**
 * @deprecated - use {@see verifySignaturesWithPublicKeys} instead
 * Get signature verifications for multsig transaction
 * @param transaction
 * @param inputIndex
 * @param amount - must be set for segwit transactions and BIP143 transactions
 * @param verificationSettings
 * @param prevOutputs - must be set for p2tr transactions
 * @returns SignatureVerification[] - in order of parsed non-empty signatures
 */
function getSignatureVerifications(transaction, inputIndex, amount, verificationSettings = {}, prevOutputs) {
    /* istanbul ignore next */
    if (!transaction.ins) {
        throw new Error(`invalid transaction`);
    }
    const input = transaction.ins[inputIndex];
    /* istanbul ignore next */
    if (!input) {
        throw new Error(`no input at index ${inputIndex}`);
    }
    if ((!input.script || input.script.length === 0) && input.witness.length === 0) {
        // Unsigned input: no signatures.
        return [];
    }
    const parsedScript = parseInput_1.parseSignatureScript2Of3(input);
    const signatures = parsedScript.signatures
        .filter((s) => s && s.length)
        .filter((s, i) => verificationSettings.signatureIndex === undefined || verificationSettings.signatureIndex === i);
    const publicKeys = parsedScript.publicKeys.filter((buf) => verificationSettings.publicKey === undefined ||
        verificationSettings.publicKey.equals(buf) ||
        verificationSettings.publicKey.slice(1).equals(buf));
    return signatures.map((signatureBuffer) => {
        if (signatureBuffer === 0 || signatureBuffer.length === 0) {
            return { signedBy: undefined, signature: undefined };
        }
        let hashType = bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT;
        if (signatureBuffer.length === 65) {
            hashType = signatureBuffer[signatureBuffer.length - 1];
            signatureBuffer = signatureBuffer.slice(0, -1);
        }
        if (parsedScript.scriptType === 'p2tr') {
            if (verificationSettings.signatureIndex !== undefined) {
                throw new Error(`signatureIndex parameter not supported for p2tr`);
            }
            if (!prevOutputs) {
                throw new Error(`prevOutputs not set`);
            }
            if (prevOutputs.length !== transaction.ins.length) {
                throw new Error(`prevOutputs length ${prevOutputs.length}, expected ${transaction.ins.length}`);
            }
            if (!('controlBlock' in parsedScript)) {
                throw new Error('expected controlBlock');
            }
            const { controlBlock, pubScript } = parsedScript;
            const leafHash = bitcoinjs_lib_1.taproot.getTapleafHash(noble_ecc_1.ecc, controlBlock, pubScript);
            const signatureHash = transaction.hashForWitnessV1(inputIndex, prevOutputs.map(({ script }) => script), prevOutputs.map(({ value }) => value), hashType, leafHash);
            const signedBy = publicKeys.filter((k) => Buffer.isBuffer(signatureBuffer) && noble_ecc_1.ecc.verifySchnorr(signatureHash, k, signatureBuffer));
            if (signedBy.length === 0) {
                return { signedBy: undefined, signature: undefined };
            }
            if (signedBy.length === 1) {
                return { signedBy: signedBy[0], signature: signatureBuffer };
            }
            throw new Error(`illegal state: signed by multiple public keys`);
        }
        else {
            // slice the last byte from the signature hash input because it's the hash type
            const { signature, hashType } = bitcoinjs_lib_1.ScriptSignature.decode(signatureBuffer);
            const transactionHash = parsedScript.scriptType === 'p2shP2wsh' || parsedScript.scriptType === 'p2wsh'
                ? transaction.hashForWitnessV0(inputIndex, parsedScript.pubScript, amount, hashType)
                : transaction.hashForSignatureByNetwork(inputIndex, parsedScript.pubScript, amount, hashType);
            const signedBy = publicKeys.filter((publicKey) => noble_ecc_1.ecc.verify(transactionHash, publicKey, signature, 
            /*
              Strict verification (require lower-S value), as required by BIP-0146
              https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki
              https://github.com/bitcoin-core/secp256k1/blob/ac83be33/include/secp256k1.h#L478-L508
              https://github.com/bitcoinjs/tiny-secp256k1/blob/v1.1.6/js.js#L231-L233
            */
            true));
            if (signedBy.length === 0) {
                return { signedBy: undefined, signature: undefined };
            }
            if (signedBy.length === 1) {
                return { signedBy: signedBy[0], signature: signatureBuffer };
            }
            throw new Error(`illegal state: signed by multiple public keys`);
        }
    });
}
exports.getSignatureVerifications = getSignatureVerifications;
/**
 * @deprecated use {@see verifySignatureWithPublicKeys} instead
 * @param transaction
 * @param inputIndex
 * @param amount
 * @param verificationSettings - if publicKey is specified, returns true iff any signature is signed by publicKey.
 * @param prevOutputs - must be set for p2tr transactions
 */
function verifySignature(transaction, inputIndex, amount, verificationSettings = {}, prevOutputs) {
    const signatureVerifications = getSignatureVerifications(transaction, inputIndex, amount, verificationSettings, prevOutputs).filter((v) => 
    // If no publicKey is set in verificationSettings, all signatures must be valid.
    // Otherwise, a single valid signature by the specified pubkey is sufficient.
    verificationSettings.publicKey === undefined ||
        (v.signedBy !== undefined &&
            (verificationSettings.publicKey.equals(v.signedBy) ||
                verificationSettings.publicKey.slice(1).equals(v.signedBy))));
    return signatureVerifications.length > 0 && signatureVerifications.every((v) => v.signedBy !== undefined);
}
exports.verifySignature = verifySignature;
/**
 * @param v
 * @param publicKey
 * @return true iff signature is by publicKey (or xonly variant of publicKey)
 */
function isSignatureByPublicKey(v, publicKey) {
    return (!!v.signedBy &&
        (v.signedBy.equals(publicKey) ||
            /* for p2tr signatures, we pass the pubkey in 33-byte format recover it from the signature in 32-byte format */
            (publicKey.length === 33 && isSignatureByPublicKey(v, publicKey.slice(1)))));
}
/**
 * @param transaction
 * @param inputIndex
 * @param prevOutputs
 * @param publicKeys
 * @return array with signature corresponding to n-th key, undefined if no match found
 */
function getSignaturesWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys) {
    if (transaction.ins.length !== prevOutputs.length) {
        throw new Error(`input length must match prevOutputs length`);
    }
    const signatureVerifications = getSignatureVerifications(transaction, inputIndex, prevOutputs[inputIndex].value, {}, prevOutputs);
    return publicKeys.map((publicKey) => {
        const v = signatureVerifications.find((v) => isSignatureByPublicKey(v, publicKey));
        return v ? v.signature : undefined;
    });
}
exports.getSignaturesWithPublicKeys = getSignaturesWithPublicKeys;
/**
 * @param transaction
 * @param inputIndex
 * @param prevOutputs - transaction outputs for inputs
 * @param publicKeys - public keys to check signatures for
 * @return array of booleans indicating a valid signature for every pubkey in _publicKeys_
 */
function verifySignatureWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys) {
    return getSignaturesWithPublicKeys(transaction, inputIndex, prevOutputs, publicKeys).map((s) => s !== undefined);
}
exports.verifySignatureWithPublicKeys = verifySignatureWithPublicKeys;
/**
 * Wrapper for {@see verifySignatureWithPublicKeys} for single pubkey
 * @param transaction
 * @param inputIndex
 * @param prevOutputs
 * @param publicKey
 * @return true iff signature is valid
 */
function verifySignatureWithPublicKey(transaction, inputIndex, prevOutputs, publicKey) {
    return verifySignatureWithPublicKeys(transaction, inputIndex, prevOutputs, [publicKey])[0];
}
exports.verifySignatureWithPublicKey = verifySignatureWithPublicKey;
function getDefaultSigHash(network, scriptType) {
    switch (networks_1.getMainnet(network)) {
        case networks_1.networks.bitcoincash:
        case networks_1.networks.bitcoinsv:
        case networks_1.networks.bitcoingold:
        case networks_1.networks.ecash:
            return bitcoinjs_lib_1.Transaction.SIGHASH_ALL | UtxoTransaction_1.UtxoTransaction.SIGHASH_FORKID;
        default:
            return scriptType === 'p2tr' ? bitcoinjs_lib_1.Transaction.SIGHASH_DEFAULT : bitcoinjs_lib_1.Transaction.SIGHASH_ALL;
    }
}
exports.getDefaultSigHash = getDefaultSigHash;
function signInputP2shP2pk(txBuilder, vin, keyPair) {
    const prevOutScriptType = 'p2sh-p2pk';
    const { redeemScript, witnessScript } = outputScripts_1.createOutputScriptP2shP2pk(keyPair.publicKey);
    keyPair.network = txBuilder.network;
    txBuilder.sign({
        vin,
        prevOutScriptType,
        keyPair,
        hashType: getDefaultSigHash(txBuilder.network),
        redeemScript,
        witnessScript,
        witnessValue: undefined,
    });
}
exports.signInputP2shP2pk = signInputP2shP2pk;
function signInput2Of3(txBuilder, vin, scriptType, pubkeys, keyPair, cosigner, amount) {
    let controlBlock;
    let redeemScript;
    let witnessScript;
    const prevOutScriptType = outputScripts_1.scriptType2Of3AsPrevOutType(scriptType);
    if (scriptType === 'p2tr') {
        ({ witnessScript, controlBlock } = outputScripts_1.createSpendScriptP2tr(pubkeys, [keyPair.publicKey, cosigner]));
    }
    else {
        ({ redeemScript, witnessScript } = outputScripts_1.createOutputScript2of3(pubkeys, scriptType));
    }
    keyPair.network = txBuilder.network;
    txBuilder.sign({
        vin,
        prevOutScriptType,
        keyPair,
        hashType: getDefaultSigHash(txBuilder.network, scriptType),
        redeemScript,
        witnessScript,
        witnessValue: amount,
        controlBlock,
    });
}
exports.signInput2Of3 = signInput2Of3;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmF0dXJlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2JpdGdvL3NpZ25hdHVyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSxpREFBZ0Y7QUFFaEYsdURBQW9EO0FBRXBELG1EQU15QjtBQUV6QiwwQ0FBNEQ7QUFDNUQsNENBQTZDO0FBQzdDLDZDQUF3RDtBQThCeEQ7Ozs7Ozs7OztHQVNHO0FBQ0gsU0FBZ0IseUJBQXlCLENBQ3ZDLFdBQXFDLEVBQ3JDLFVBQWtCLEVBQ2xCLE1BQWUsRUFDZix1QkFBNkMsRUFBRSxFQUMvQyxXQUFpQztJQUVqQywwQkFBMEI7SUFDMUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUU7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0tBQ3hDO0lBRUQsTUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUMxQywwQkFBMEI7SUFDMUIsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLFVBQVUsRUFBRSxDQUFDLENBQUM7S0FDcEQ7SUFFRCxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUM5RSxpQ0FBaUM7UUFDakMsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUVELE1BQU0sWUFBWSxHQUFHLHFDQUF3QixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXJELE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxVQUFVO1NBQ3ZDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUM7U0FDNUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFF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UyxDQUFDLE9BQWtCLENBQUM7UUFDekQsWUFBWTtRQUNaLGFBQWE7UUFDYixZQUFZLEVBQUUsU0FBUztLQUN4QixDQUFDLENBQUM7QUFDTCxDQUFDO0FBbEJELDhDQWtCQztBQUVELFNBQWdCLGFBQWEsQ0FDM0IsU0FBMEMsRUFDMUMsR0FBVyxFQUNYLFVBQTBCLEVBQzFCLE9BQXVCLEVBQ3ZCLE9BQXVCLEVBQ3ZCLFFBQWdCLEVBQ2hCLE1BQWU7SUFFZixJQUFJLFlBQVksQ0FBQztJQUNqQixJQUFJLFlBQVksQ0FBQztJQUNqQixJQUFJLGFBQWEsQ0FBQztJQUVsQixNQUFNLGlCQUFpQixHQUFHLDJDQUEyQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2xFLElBQUksVUFBVSxLQUFLLE1BQU0sRUFBRTtRQUN6QixDQUFDLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxHQUFHLHFDQUFxQixDQUFDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ25HO1NBQU07UUFDTCxDQUFDLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxHQUFHLHNDQUFzQixDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0tBQ2pGO0lBRUQsT0FBTyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDO0lBRXBDLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDYixHQUFHO1FBQ0gsaUJBQWlCO1FBQ2pCLE9BQU87UUFDUCxRQUFRLEVBQUUsaUJBQWlCLENBQUMsU0FBUyxDQUFDLE9BQWtCLEVBQUUsVUFBVSxDQUFDO1FBQ3JFLFlBQVk7UUFDWixhQUFhO1FBQ2IsWUFBWSxFQUFFLE1BQU07UUFDcEIsWUFBWTtLQUNiLENBQUMsQ0FBQztBQUNMLENBQUM7QUFoQ0Qsc0NBZ0NDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQklQMzJJbnRlcmZhY2UgfSBmcm9tICdiaXAzMic7XG5cbmltcG9ydCB7IFRyYW5zYWN0aW9uLCB0YXByb290LCBUeE91dHB1dCwgU2NyaXB0U2lnbmF0dXJlIH0gZnJvbSAnYml0Y29pbmpzLWxpYic7XG5cbmltcG9ydCB7IFV0eG9UcmFuc2FjdGlvbiB9IGZyb20gJy4vVXR4b1RyYW5zYWN0aW9uJztcbmltcG9ydCB7IFV0eG9UcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuL1V0eG9UcmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHtcbiAgY3JlYXRlT3V0cHV0U2NyaXB0Mm9mMyxcbiAgY3JlYXRlT3V0cHV0U2NyaXB0UDJzaFAycGssXG4gIGNyZWF0ZVNwZW5kU2NyaXB0UDJ0cixcbiAgU2NyaXB0VHlwZTJPZjMsXG4gIHNjcmlwdFR5cGUyT2YzQXNQcmV2T3V0VHlwZSxcbn0gZnJvbSAnLi9vdXRwdXRTY3JpcHRzJztcbmltcG9ydCB7IFRyaXBsZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TWFpbm5ldCwgTmV0d29yaywgbmV0d29ya3MgfSBmcm9tICcuLi9uZXR3b3Jrcyc7XG5pbXBvcnQgeyBlY2MgYXMgZWNjTGliIH0gZnJvbSAnLi4vbm9ibGVfZWNjJztcbmltcG9ydCB7IHBhcnNlU2lnbmF0dXJlU2NyaXB0Mk9mMyB9IGZyb20gJy4vcGFyc2VJbnB1dCc7XG5cbi8qKlxuICogQ29uc3RyYWludHMgZm9yIHNpZ25hdHVyZSB2ZXJpZmljYXRpb25zLlxuICogUGFyYW1ldGVycyBhcmUgY29uanVuY3RpdmU6IGlmIG11bHRpcGxlIHBhcmFtZXRlcnMgYXJlIHNldCwgYSB2ZXJpZmljYXRpb24gZm9yIGFuIGluZGl2aWR1YWxcbiAqIHNpZ25hdHVyZSBtdXN0IHNhdGlzZnkgYWxsIG9mIHRoZW0uXG4gKi9cbmV4cG9ydCB0eXBlIFZlcmlmaWNhdGlvblNldHRpbmdzID0ge1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBzaWduYXR1cmUgdG8gdmVyaWZ5LiBPbmx5IGl0ZXJhdGVzIG92ZXIgbm9uLWVtcHR5IHNpZ25hdHVyZXMuXG4gICAqL1xuICBzaWduYXR1cmVJbmRleD86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IHRvIHZlcmlmeS5cbiAgICovXG4gIHB1YmxpY0tleT86IEJ1ZmZlcjtcbn07XG5cbi8qKlxuICogUmVzdWx0IGZvciBhIGluZGl2aWR1YWwgc2lnbmF0dXJlIHZlcmlmaWNhdGlvblxuICovXG5leHBvcnQgdHlwZSBTaWduYXR1cmVWZXJpZmljYXRpb24gPVxuICB8IHtcbiAgICAgIC8qKiBTZXQgdG8gdGhlIHB1YmxpYyBrZXkgdGhhdCBzaWduZWQgZm9yIHRoZSBzaWduYXR1cmUgKi9cbiAgICAgIHNpZ25lZEJ5OiBCdWZmZXI7XG4gICAgICAvKiogU2V0IHRvIHRoZSBzaWduYXR1cmUgYnVmZmVyICovXG4gICAgICBzaWduYXR1cmU6IEJ1ZmZlcjtcbiAgICB9XG4gIHwgeyBzaWduZWRCeTogdW5kZWZpbmVkOyBzaWduYXR1cmU6IHVuZGVmaW5lZCB9O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIC0gdXNlIHtAc2VlIHZlcmlmeVNpZ25hdHVyZXNXaXRoUHVibGljS2V5c30gaW5zdGVhZFxuICogR2V0IHNpZ25hdHVyZSB2ZXJpZmljYXRpb25zIGZvciBtdWx0c2lnIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBpbnB1dEluZGV4XG4gKiBAcGFyYW0gYW1vdW50IC0gbXVzdCBiZSBzZXQgZm9yIHNlZ3dpdCB0cmFuc2FjdGlvbnMgYW5kIEJJUDE0MyB0cmFuc2FjdGlvbnNcbiAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5nc1xuICogQHBhcmFtIHByZXZPdXRwdXRzIC0gbXVzdCBiZSBzZXQgZm9yIHAydHIgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVWZXJpZmljYXRpb25bXSAtIGluIG9yZGVyIG9mIHBhcnNlZCBub24tZW1wdHkgc2lnbmF0dXJlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlVmVyaWZpY2F0aW9uczxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHJhbnNhY3Rpb246IFV0eG9UcmFuc2FjdGlvbjxUTnVtYmVyPixcbiAgaW5wdXRJbmRleDogbnVtYmVyLFxuICBhbW91bnQ6IFROdW1iZXIsXG4gIHZlcmlmaWNhdGlvblNldHRpbmdzOiBWZXJpZmljYXRpb25TZXR0aW5ncyA9IHt9LFxuICBwcmV2T3V0cHV0cz86IFR4T3V0cHV0PFROdW1iZXI+W11cbik6IFNpZ25hdHVyZVZlcmlmaWNhdGlvbltdIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCF0cmFuc2FjdGlvbi5pbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHJhbnNhY3Rpb25gKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0ID0gdHJhbnNhY3Rpb24uaW5zW2lucHV0SW5kZXhdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWlucHV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBpbnB1dCBhdCBpbmRleCAke2lucHV0SW5kZXh9YCk7XG4gIH1cblxuICBpZiAoKCFpbnB1dC5zY3JpcHQgfHwgaW5wdXQuc2NyaXB0Lmxlbmd0aCA9PT0gMCkgJiYgaW5wdXQud2l0bmVzcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBVbnNpZ25lZCBpbnB1dDogbm8gc2lnbmF0dXJlcy5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBwYXJzZWRTY3JpcHQgPSBwYXJzZVNpZ25hdHVyZVNjcmlwdDJPZjMoaW5wdXQpO1xuXG4gIGNvbnN0IHNpZ25hdHVyZXMgPSBwYXJzZWRTY3JpcHQuc2lnbmF0dXJlc1xuICAgIC5maWx0ZXIoKHMpID0+IHMgJiYgcy5sZW5ndGgpXG4gICAgLmZpbHRlcigocywgaSkgPT4gdmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXggPT09IHVuZGVmaW5lZCB8fCB2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCA9PT0gaSk7XG5cbiAgY29uc3QgcHVibGljS2V5cyA9IHBhcnNlZFNjcmlwdC5wdWJsaWNLZXlzLmZpbHRlcihcbiAgICAoYnVmKSA9PlxuICAgICAgdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleS5lcXVhbHMoYnVmKSB8fFxuICAgICAgdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5LnNsaWNlKDEpLmVxdWFscyhidWYpXG4gICk7XG5cbiAgcmV0dXJuIHNpZ25hdHVyZXMubWFwKChzaWduYXR1cmVCdWZmZXIpOiBTaWduYXR1cmVWZXJpZmljYXRpb24gPT4ge1xuICAgIGlmIChzaWduYXR1cmVCdWZmZXIgPT09IDAgfHwgc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgc2lnbmVkQnk6IHVuZGVmaW5lZCwgc2lnbmF0dXJlOiB1bmRlZmluZWQgfTtcbiAgICB9XG5cbiAgICBsZXQgaGFzaFR5cGUgPSBUcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQ7XG5cbiAgICBpZiAoc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgIGhhc2hUeXBlID0gc2lnbmF0dXJlQnVmZmVyW3NpZ25hdHVyZUJ1ZmZlci5sZW5ndGggLSAxXTtcbiAgICAgIHNpZ25hdHVyZUJ1ZmZlciA9IHNpZ25hdHVyZUJ1ZmZlci5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlZFNjcmlwdC5zY3JpcHRUeXBlID09PSAncDJ0cicpIHtcbiAgICAgIGlmICh2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlSW5kZXggcGFyYW1ldGVyIG5vdCBzdXBwb3J0ZWQgZm9yIHAydHJgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwcmV2T3V0cHV0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZXZPdXRwdXRzIG5vdCBzZXRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZPdXRwdXRzLmxlbmd0aCAhPT0gdHJhbnNhY3Rpb24uaW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZXZPdXRwdXRzIGxlbmd0aCAke3ByZXZPdXRwdXRzLmxlbmd0aH0sIGV4cGVjdGVkICR7dHJhbnNhY3Rpb24uaW5zLmxlbmd0aH1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoJ2NvbnRyb2xCbG9jaycgaW4gcGFyc2VkU2NyaXB0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGNvbnRyb2xCbG9jaycpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjb250cm9sQmxvY2ssIHB1YlNjcmlwdCB9ID0gcGFyc2VkU2NyaXB0O1xuICAgICAgY29uc3QgbGVhZkhhc2ggPSB0YXByb290LmdldFRhcGxlYWZIYXNoKGVjY0xpYiwgY29udHJvbEJsb2NrLCBwdWJTY3JpcHQpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlSGFzaCA9IHRyYW5zYWN0aW9uLmhhc2hGb3JXaXRuZXNzVjEoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIHByZXZPdXRwdXRzLm1hcCgoeyBzY3JpcHQgfSkgPT4gc2NyaXB0KSxcbiAgICAgICAgcHJldk91dHB1dHMubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKSxcbiAgICAgICAgaGFzaFR5cGUsXG4gICAgICAgIGxlYWZIYXNoXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzaWduZWRCeSA9IHB1YmxpY0tleXMuZmlsdGVyKFxuICAgICAgICAoaykgPT4gQnVmZmVyLmlzQnVmZmVyKHNpZ25hdHVyZUJ1ZmZlcikgJiYgZWNjTGliLnZlcmlmeVNjaG5vcnIoc2lnbmF0dXJlSGFzaCwgaywgc2lnbmF0dXJlQnVmZmVyKVxuICAgICAgKTtcblxuICAgICAgaWYgKHNpZ25lZEJ5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyBzaWduZWRCeTogdW5kZWZpbmVkLCBzaWduYXR1cmU6IHVuZGVmaW5lZCB9O1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25lZEJ5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBzaWduZWRCeTogc2lnbmVkQnlbMF0sIHNpZ25hdHVyZTogc2lnbmF0dXJlQnVmZmVyIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlsbGVnYWwgc3RhdGU6IHNpZ25lZCBieSBtdWx0aXBsZSBwdWJsaWMga2V5c2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzbGljZSB0aGUgbGFzdCBieXRlIGZyb20gdGhlIHNpZ25hdHVyZSBoYXNoIGlucHV0IGJlY2F1c2UgaXQncyB0aGUgaGFzaCB0eXBlXG4gICAgICBjb25zdCB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfSA9IFNjcmlwdFNpZ25hdHVyZS5kZWNvZGUoc2lnbmF0dXJlQnVmZmVyKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9XG4gICAgICAgIHBhcnNlZFNjcmlwdC5zY3JpcHRUeXBlID09PSAncDJzaFAyd3NoJyB8fCBwYXJzZWRTY3JpcHQuc2NyaXB0VHlwZSA9PT0gJ3Ayd3NoJ1xuICAgICAgICAgID8gdHJhbnNhY3Rpb24uaGFzaEZvcldpdG5lc3NWMChpbnB1dEluZGV4LCBwYXJzZWRTY3JpcHQucHViU2NyaXB0LCBhbW91bnQsIGhhc2hUeXBlKVxuICAgICAgICAgIDogdHJhbnNhY3Rpb24uaGFzaEZvclNpZ25hdHVyZUJ5TmV0d29yayhpbnB1dEluZGV4LCBwYXJzZWRTY3JpcHQucHViU2NyaXB0LCBhbW91bnQsIGhhc2hUeXBlKTtcbiAgICAgIGNvbnN0IHNpZ25lZEJ5ID0gcHVibGljS2V5cy5maWx0ZXIoKHB1YmxpY0tleSkgPT5cbiAgICAgICAgZWNjTGliLnZlcmlmeShcbiAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgU3RyaWN0IHZlcmlmaWNhdGlvbiAocmVxdWlyZSBsb3dlci1TIHZhbHVlKSwgYXMgcmVxdWlyZWQgYnkgQklQLTAxNDZcbiAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAxNDYubWVkaWF3aWtpXG4gICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi1jb3JlL3NlY3AyNTZrMS9ibG9iL2FjODNiZTMzL2luY2x1ZGUvc2VjcDI1NmsxLmgjTDQ3OC1MNTA4XG4gICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL3Rpbnktc2VjcDI1NmsxL2Jsb2IvdjEuMS42L2pzLmpzI0wyMzEtTDIzM1xuICAgICAgICAgICovXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBpZiAoc2lnbmVkQnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHNpZ25lZEJ5OiB1bmRlZmluZWQsIHNpZ25hdHVyZTogdW5kZWZpbmVkIH07XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmVkQnkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7IHNpZ25lZEJ5OiBzaWduZWRCeVswXSwgc2lnbmF0dXJlOiBzaWduYXR1cmVCdWZmZXIgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgaWxsZWdhbCBzdGF0ZTogc2lnbmVkIGJ5IG11bHRpcGxlIHB1YmxpYyBrZXlzYCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BzZWUgdmVyaWZ5U2lnbmF0dXJlV2l0aFB1YmxpY0tleXN9IGluc3RlYWRcbiAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGlucHV0SW5kZXhcbiAqIEBwYXJhbSBhbW91bnRcbiAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5ncyAtIGlmIHB1YmxpY0tleSBpcyBzcGVjaWZpZWQsIHJldHVybnMgdHJ1ZSBpZmYgYW55IHNpZ25hdHVyZSBpcyBzaWduZWQgYnkgcHVibGljS2V5LlxuICogQHBhcmFtIHByZXZPdXRwdXRzIC0gbXVzdCBiZSBzZXQgZm9yIHAydHIgdHJhbnNhY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmU8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gIHRyYW5zYWN0aW9uOiBVdHhvVHJhbnNhY3Rpb248VE51bWJlcj4sXG4gIGlucHV0SW5kZXg6IG51bWJlcixcbiAgYW1vdW50OiBUTnVtYmVyLFxuICB2ZXJpZmljYXRpb25TZXR0aW5nczogVmVyaWZpY2F0aW9uU2V0dGluZ3MgPSB7fSxcbiAgcHJldk91dHB1dHM/OiBUeE91dHB1dDxUTnVtYmVyPltdXG4pOiBib29sZWFuIHtcbiAgY29uc3Qgc2lnbmF0dXJlVmVyaWZpY2F0aW9ucyA9IGdldFNpZ25hdHVyZVZlcmlmaWNhdGlvbnMoXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgaW5wdXRJbmRleCxcbiAgICBhbW91bnQsXG4gICAgdmVyaWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgcHJldk91dHB1dHNcbiAgKS5maWx0ZXIoXG4gICAgKHYpID0+XG4gICAgICAvLyBJZiBubyBwdWJsaWNLZXkgaXMgc2V0IGluIHZlcmlmaWNhdGlvblNldHRpbmdzLCBhbGwgc2lnbmF0dXJlcyBtdXN0IGJlIHZhbGlkLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBhIHNpbmdsZSB2YWxpZCBzaWduYXR1cmUgYnkgdGhlIHNwZWNpZmllZCBwdWJrZXkgaXMgc3VmZmljaWVudC5cbiAgICAgIHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAodi5zaWduZWRCeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICh2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXkuZXF1YWxzKHYuc2lnbmVkQnkpIHx8XG4gICAgICAgICAgdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5LnNsaWNlKDEpLmVxdWFscyh2LnNpZ25lZEJ5KSkpXG4gICk7XG5cbiAgcmV0dXJuIHNpZ25hdHVyZVZlcmlmaWNhdGlvbnMubGVuZ3RoID4gMCAmJiBzaWduYXR1cmVWZXJpZmljYXRpb25zLmV2ZXJ5KCh2KSA9PiB2LnNpZ25lZEJ5ICE9PSB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB2XG4gKiBAcGFyYW0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHRydWUgaWZmIHNpZ25hdHVyZSBpcyBieSBwdWJsaWNLZXkgKG9yIHhvbmx5IHZhcmlhbnQgb2YgcHVibGljS2V5KVxuICovXG5mdW5jdGlvbiBpc1NpZ25hdHVyZUJ5UHVibGljS2V5KHY6IFNpZ25hdHVyZVZlcmlmaWNhdGlvbiwgcHVibGljS2V5OiBCdWZmZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICAhIXYuc2lnbmVkQnkgJiZcbiAgICAodi5zaWduZWRCeS5lcXVhbHMocHVibGljS2V5KSB8fFxuICAgICAgLyogZm9yIHAydHIgc2lnbmF0dXJlcywgd2UgcGFzcyB0aGUgcHVia2V5IGluIDMzLWJ5dGUgZm9ybWF0IHJlY292ZXIgaXQgZnJvbSB0aGUgc2lnbmF0dXJlIGluIDMyLWJ5dGUgZm9ybWF0ICovXG4gICAgICAocHVibGljS2V5Lmxlbmd0aCA9PT0gMzMgJiYgaXNTaWduYXR1cmVCeVB1YmxpY0tleSh2LCBwdWJsaWNLZXkuc2xpY2UoMSkpKSlcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBpbnB1dEluZGV4XG4gKiBAcGFyYW0gcHJldk91dHB1dHNcbiAqIEBwYXJhbSBwdWJsaWNLZXlzXG4gKiBAcmV0dXJuIGFycmF5IHdpdGggc2lnbmF0dXJlIGNvcnJlc3BvbmRpbmcgdG8gbi10aCBrZXksIHVuZGVmaW5lZCBpZiBubyBtYXRjaCBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlc1dpdGhQdWJsaWNLZXlzPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0cmFuc2FjdGlvbjogVXR4b1RyYW5zYWN0aW9uPFROdW1iZXI+LFxuICBpbnB1dEluZGV4OiBudW1iZXIsXG4gIHByZXZPdXRwdXRzOiBUeE91dHB1dDxUTnVtYmVyPltdLFxuICBwdWJsaWNLZXlzOiBCdWZmZXJbXVxuKTogQXJyYXk8QnVmZmVyIHwgdW5kZWZpbmVkPiB7XG4gIGlmICh0cmFuc2FjdGlvbi5pbnMubGVuZ3RoICE9PSBwcmV2T3V0cHV0cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGxlbmd0aCBtdXN0IG1hdGNoIHByZXZPdXRwdXRzIGxlbmd0aGApO1xuICB9XG5cbiAgY29uc3Qgc2lnbmF0dXJlVmVyaWZpY2F0aW9ucyA9IGdldFNpZ25hdHVyZVZlcmlmaWNhdGlvbnMoXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgaW5wdXRJbmRleCxcbiAgICBwcmV2T3V0cHV0c1tpbnB1dEluZGV4XS52YWx1ZSxcbiAgICB7fSxcbiAgICBwcmV2T3V0cHV0c1xuICApO1xuXG4gIHJldHVybiBwdWJsaWNLZXlzLm1hcCgocHVibGljS2V5KSA9PiB7XG4gICAgY29uc3QgdiA9IHNpZ25hdHVyZVZlcmlmaWNhdGlvbnMuZmluZCgodikgPT4gaXNTaWduYXR1cmVCeVB1YmxpY0tleSh2LCBwdWJsaWNLZXkpKTtcbiAgICByZXR1cm4gdiA/IHYuc2lnbmF0dXJlIDogdW5kZWZpbmVkO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBpbnB1dEluZGV4XG4gKiBAcGFyYW0gcHJldk91dHB1dHMgLSB0cmFuc2FjdGlvbiBvdXRwdXRzIGZvciBpbnB1dHNcbiAqIEBwYXJhbSBwdWJsaWNLZXlzIC0gcHVibGljIGtleXMgdG8gY2hlY2sgc2lnbmF0dXJlcyBmb3JcbiAqIEByZXR1cm4gYXJyYXkgb2YgYm9vbGVhbnMgaW5kaWNhdGluZyBhIHZhbGlkIHNpZ25hdHVyZSBmb3IgZXZlcnkgcHVia2V5IGluIF9wdWJsaWNLZXlzX1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlV2l0aFB1YmxpY0tleXM8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gIHRyYW5zYWN0aW9uOiBVdHhvVHJhbnNhY3Rpb248VE51bWJlcj4sXG4gIGlucHV0SW5kZXg6IG51bWJlcixcbiAgcHJldk91dHB1dHM6IFR4T3V0cHV0PFROdW1iZXI+W10sXG4gIHB1YmxpY0tleXM6IEJ1ZmZlcltdXG4pOiBib29sZWFuW10ge1xuICByZXR1cm4gZ2V0U2lnbmF0dXJlc1dpdGhQdWJsaWNLZXlzKHRyYW5zYWN0aW9uLCBpbnB1dEluZGV4LCBwcmV2T3V0cHV0cywgcHVibGljS2V5cykubWFwKChzKSA9PiBzICE9PSB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIFdyYXBwZXIgZm9yIHtAc2VlIHZlcmlmeVNpZ25hdHVyZVdpdGhQdWJsaWNLZXlzfSBmb3Igc2luZ2xlIHB1YmtleVxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gaW5wdXRJbmRleFxuICogQHBhcmFtIHByZXZPdXRwdXRzXG4gKiBAcGFyYW0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHRydWUgaWZmIHNpZ25hdHVyZSBpcyB2YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlV2l0aFB1YmxpY0tleTxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHJhbnNhY3Rpb246IFV0eG9UcmFuc2FjdGlvbjxUTnVtYmVyPixcbiAgaW5wdXRJbmRleDogbnVtYmVyLFxuICBwcmV2T3V0cHV0czogVHhPdXRwdXQ8VE51bWJlcj5bXSxcbiAgcHVibGljS2V5OiBCdWZmZXJcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gdmVyaWZ5U2lnbmF0dXJlV2l0aFB1YmxpY0tleXModHJhbnNhY3Rpb24sIGlucHV0SW5kZXgsIHByZXZPdXRwdXRzLCBbcHVibGljS2V5XSlbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0U2lnSGFzaChuZXR3b3JrOiBOZXR3b3JrLCBzY3JpcHRUeXBlPzogU2NyaXB0VHlwZTJPZjMpOiBudW1iZXIge1xuICBzd2l0Y2ggKGdldE1haW5uZXQobmV0d29yaykpIHtcbiAgICBjYXNlIG5ldHdvcmtzLmJpdGNvaW5jYXNoOlxuICAgIGNhc2UgbmV0d29ya3MuYml0Y29pbnN2OlxuICAgIGNhc2UgbmV0d29ya3MuYml0Y29pbmdvbGQ6XG4gICAgY2FzZSBuZXR3b3Jrcy5lY2FzaDpcbiAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCB8IFV0eG9UcmFuc2FjdGlvbi5TSUdIQVNIX0ZPUktJRDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHNjcmlwdFR5cGUgPT09ICdwMnRyJyA/IFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCA6IFRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaWduSW5wdXRQMnNoUDJwazxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50PihcbiAgdHhCdWlsZGVyOiBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyPFROdW1iZXI+LFxuICB2aW46IG51bWJlcixcbiAga2V5UGFpcjogQklQMzJJbnRlcmZhY2Vcbik6IHZvaWQge1xuICBjb25zdCBwcmV2T3V0U2NyaXB0VHlwZSA9ICdwMnNoLXAycGsnO1xuICBjb25zdCB7IHJlZGVlbVNjcmlwdCwgd2l0bmVzc1NjcmlwdCB9ID0gY3JlYXRlT3V0cHV0U2NyaXB0UDJzaFAycGsoa2V5UGFpci5wdWJsaWNLZXkpO1xuICBrZXlQYWlyLm5ldHdvcmsgPSB0eEJ1aWxkZXIubmV0d29yaztcblxuICB0eEJ1aWxkZXIuc2lnbih7XG4gICAgdmluLFxuICAgIHByZXZPdXRTY3JpcHRUeXBlLFxuICAgIGtleVBhaXIsXG4gICAgaGFzaFR5cGU6IGdldERlZmF1bHRTaWdIYXNoKHR4QnVpbGRlci5uZXR3b3JrIGFzIE5ldHdvcmspLFxuICAgIHJlZGVlbVNjcmlwdCxcbiAgICB3aXRuZXNzU2NyaXB0LFxuICAgIHdpdG5lc3NWYWx1ZTogdW5kZWZpbmVkLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpZ25JbnB1dDJPZjM8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gIHR4QnVpbGRlcjogVXR4b1RyYW5zYWN0aW9uQnVpbGRlcjxUTnVtYmVyPixcbiAgdmluOiBudW1iZXIsXG4gIHNjcmlwdFR5cGU6IFNjcmlwdFR5cGUyT2YzLFxuICBwdWJrZXlzOiBUcmlwbGU8QnVmZmVyPixcbiAga2V5UGFpcjogQklQMzJJbnRlcmZhY2UsXG4gIGNvc2lnbmVyOiBCdWZmZXIsXG4gIGFtb3VudDogVE51bWJlclxuKTogdm9pZCB7XG4gIGxldCBjb250cm9sQmxvY2s7XG4gIGxldCByZWRlZW1TY3JpcHQ7XG4gIGxldCB3aXRuZXNzU2NyaXB0O1xuXG4gIGNvbnN0IHByZXZPdXRTY3JpcHRUeXBlID0gc2NyaXB0VHlwZTJPZjNBc1ByZXZPdXRUeXBlKHNjcmlwdFR5cGUpO1xuICBpZiAoc2NyaXB0VHlwZSA9PT0gJ3AydHInKSB7XG4gICAgKHsgd2l0bmVzc1NjcmlwdCwgY29udHJvbEJsb2NrIH0gPSBjcmVhdGVTcGVuZFNjcmlwdFAydHIocHVia2V5cywgW2tleVBhaXIucHVibGljS2V5LCBjb3NpZ25lcl0pKTtcbiAgfSBlbHNlIHtcbiAgICAoeyByZWRlZW1TY3JpcHQsIHdpdG5lc3NTY3JpcHQgfSA9IGNyZWF0ZU91dHB1dFNjcmlwdDJvZjMocHVia2V5cywgc2NyaXB0VHlwZSkpO1xuICB9XG5cbiAga2V5UGFpci5uZXR3b3JrID0gdHhCdWlsZGVyLm5ldHdvcms7XG5cbiAgdHhCdWlsZGVyLnNpZ24oe1xuICAgIHZpbixcbiAgICBwcmV2T3V0U2NyaXB0VHlwZSxcbiAgICBrZXlQYWlyLFxuICAgIGhhc2hUeXBlOiBnZXREZWZhdWx0U2lnSGFzaCh0eEJ1aWxkZXIubmV0d29yayBhcyBOZXR3b3JrLCBzY3JpcHRUeXBlKSxcbiAgICByZWRlZW1TY3JpcHQsXG4gICAgd2l0bmVzc1NjcmlwdCxcbiAgICB3aXRuZXNzVmFsdWU6IGFtb3VudCxcbiAgICBjb250cm9sQmxvY2ssXG4gIH0pO1xufVxuIl19